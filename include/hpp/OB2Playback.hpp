#pragma once

#include "OB2Types.hpp"
#include <string>

extern "C" {
#include "h/ob2playback.h"
}

#include "hpp/OB2Camera.hpp"
#include "hpp/OB2IMU.hpp"

namespace ob2 {

/**
 * \if English
 *
 * @brief playback class, for playback of recording files generated by the record.
 *
 * \else
 *
 * @brief 回放器，用于录制器生成的录制文件的播放.
 *
 * \endif
 */
class playback {
public:
    /**
     * \if English
     *
     * @brief playback constructor
     *
     * @attention Once the playback has been successfully created it will open the recorded file, which will not be accessible via other programs until the
     * playback is destructured
     *
     * @param file_path Recorded file path
     *
     * \else
     *
     * @brief 回放器构造函数
     *
     * @attention 回放器成功创建后会将录制文件打开，此时通过其他程序将无法访问该文件，直到回放器析构
     *
     * @param file_path 录制文件路径
     *
     * \endif
     */
    playback(const std::string file_path) {
        ob2_status_t status;
        m_playback_handle = ob2_playback_create(file_path.c_str(), &status);
        CHECK_OB2_STATUS_ERROR_THROW(status);
    }

    /**
     * \if English
     *
     * @brief Constructed via other playback object (mobile constructs, mainly used in derived class implementations)
     *
     * @attention After this constructor is called, the original object will no longer be accessible.
     *
     * @param[in] pb Another playback object
     *
     * \else
     *
     * @brief 通过其他回放器对象构造（移动构造，主要用于派生类的实现）
     *
     * @attention 调用该构造函数后，原对象将不再可以访问
     *
     * @param[in] pb 其他回放器对象
     *
     * \endif
     */
    playback(playback &&pb) : m_playback_handle(pb.m_playback_handle) {
        VALIDATE_NOT_NULL(m_playback_handle);
        pb.m_playback_handle = nullptr;
    }

    /**
     * \if English
     *
     * @brief playback destructor
     *
     * \else
     *
     * @brief 回放器析构函数
     *
     * \endif
     */
    virtual ~playback() noexcept {
        ob2_status_t status;
        if(m_playback_handle != nullptr) {
            ob2_playback_close(m_playback_handle, &status);
        }
    }

    /**
     * \if English
     *
     * @brief get cameras calibration parameters
     *
     * @attention If the recording file was recorded without writing the cameras calibration parameters, a call to this interface will throw a
     * std::runtime_error exception.
     *
     * @return ob2_cameras_calibration_t  Return cameras calibration parameters
     *
     * \else
     *
     * @brief 获取已录制的设备信息
     *
     * @attention 如果录制文件录制时未写入设备信息，调用本接口将抛出 std::runtime_error 异常。
     *
     * @return ob2_device_info_t 返回设备信息
     *
     * \endif
     */
    virtual ob2_device_info_t get_device_info() {
        ob2_status_t status;
        auto         device_info = ob2_playback_get_device_info(m_playback_handle, &status);
        CHECK_OB2_STATUS_ERROR_THROW(status);
        return device_info;
    }

    /**
     * \if English
     *
     * @brief get cameras calibration parameters
     *
     * @attention If the recording file was recorded without writing the cameras calibration parameters, a call to this interface will will throw a
     * std::runtime_error exception.
     *
     * @return ob2_cameras_calibration_t  Return cameras calibration parameters
     *
     * \else
     *
     * @brief 获取相机标定参数
     *
     * @attention 如果录制文件录制时未写入相机标定参数，调用本接口将抛出 std::runtime_error 异常。
     *
     * @return ob2_cameras_calibration_t  返回相机标定参数
     *
     * \endif
     */
    virtual ob2_cameras_calibration_t get_cameras_calibration() {
        ob2_status_t status;
        auto         calibration = ob2_playback_get_cameras_calibration(m_playback_handle, &status);
        CHECK_OB2_STATUS_ERROR_THROW(status);
        return calibration;
    }

    /**
     * \if English
     *
     * @brief start playback
     *
     * @attention Do not execute too many tasks within the callback function, as this may take too long and cause the SDK internal cache to overflow and discard
     * data.
     *
     * @param[in] capture_cb  capture callback function
     * @param[in] imu_sample_cb imu_sample callback function（Not currently supported, please pass NULL）
     * @param[in] playback_state_cb  Playback status callback  function
     *
     * \else
     *
     * @brief  开启回放
     *
     * @attention 在回调函数内不要执行太多任务，否则执行时间过长会导致 SDK 内部缓存溢出而丢弃数据。
     *
     * @param[in] capture_cb  capture 回调
     * @param[in] imu_sample_cb imu_sample 回调（当前不支持，请传入 NULL）
     * @param[in] playback_state_cb  回放状态回调
     *
     * \endif
     */
    virtual void start(capture_cb capture_cb, imu_sample_cb imu_sample_cb, playback_state_cb playback_state_cb) {
        ob2_status_t status;
        m_capture_cb        = capture_cb;
        m_imu_sample_cb     = imu_sample_cb;
        m_playback_state_cb = playback_state_cb;
        ob2_playback_start(m_playback_handle, &playback::capture_callback, &playback::imu_sample_callback, &playback::playback_state_callback, this, &status);
        CHECK_OB2_STATUS_ERROR_THROW(status);
    }

    /**
     * \if English
     *
     * @brief Stop Playback
     *
     * \else
     *
     * @brief 停止回放
     *
     * \endif
     */
    virtual void stop() {
        ob2_status_t status;
        ob2_playback_stop(m_playback_handle, &status);
        CHECK_OB2_STATUS_ERROR_THROW(status);
    }

protected:
    static void capture_callback(ob2_capture_t capture_handle, void *user_data) {
        auto pb = (playback *)user_data;
        if(pb->m_capture_cb != nullptr) {
            pb->m_capture_cb(std::make_shared<capture>(std::move(capture_handle)));
        }
    }

    static void imu_sample_callback(ob2_imu_sample_t imu_sample_handle, void *user_data) {
        auto pb = (playback *)user_data;
        if(pb->m_imu_sample_cb != nullptr) {
            pb->m_imu_sample_cb(std::make_shared<imu_sample>(std::move(imu_sample_handle)));
        }
    }

    static void playback_state_callback(ob2_playback_state_t state, void *user_data) {
        auto pb = (playback *)user_data;
        if(pb->m_playback_state_cb != nullptr) {
            pb->m_playback_state_cb(state);
        }
    }

protected:
    capture_cb        m_capture_cb;
    imu_sample_cb     m_imu_sample_cb;
    playback_state_cb m_playback_state_cb;

    ob2_playback_t m_playback_handle;
};
}  // namespace ob2